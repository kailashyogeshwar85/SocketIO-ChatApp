var R                     = require('ramda');
var when                  = require('when');
var utility               = require('./utilities/utility');
var instanceMethodBuilder = require('./utilities/instanceMethodBuilder')();
var Built                 = require('./built');

/**
    @class Presence
    @classdesc
    Presence is a feature that allows you to determine if a certain application user is currently online or offline. It stores the "last seen" timestamp of the user, which is useful in chat applications. Additionally, it allows you to store the "state" associated with the user's profile (e.g., users could use it to store chat statuses).
    @instance
    @description Represents presence details of a user. Instance of presence is retrieved every time a user fetches his or someone else's presence.
    @example
      var user = app.User('abc');
      user
        .getPresence()
        .then(function(presence){
          // console.log(presence.getState());
        });
*/
var presenceCons = module.exports = R.curry(function(app,data) {
  var returnObj = {
    toJSON:function(){
      return data;
    },
    data   : data,
    app    : app
  }
  return instanceMethodBuilder.build(module.exports,returnObj);
});

/** Util methods **/
var getData               = R.prop('data');

function getMixinedData(presence){
  return R.mixin({},getData(presence));
}

var set = module.exports.set = R.curry(function(parameter,value,presence){
  var newData           = getMixinedData(presence);
  newData[parameter]    = value;
  return presenceCons(presence.app, newData);
});

/**
  Sets your state. State is similar to you status message, which can be seen by other users.
  @function setStatusMessage
  @instance
  @memberof Presence
  @param {object} state The state you want to set
  @example
      var user = app.User('abc');
      user
        .getPresence()
        .then(function(presence) {
          var newPresence = presence.setStatusMessage({
            message: 'Hello built.io'
          });
        });
  @return {Presence}
*/
module.exports.setState = module.exports.setStatusMessage = set('state');
instanceMethodBuilder.define('setState',2);

/**
  Sets your presence details that would be publicly visible. By default, presence is not avaliable publicly.
  @function setPublic
  @instance
  @memberof Presence
  @param {Boolean} public Set it to true for making presence avaliable publicly.
  @example
      var user = app.User('abc');
      user
        .getPresence()
        .then(function(presence){
          var newPresence = presence.setPublic(true);
        });
  @return {Presence}
*/

module.exports.setPublic = set('public');
instanceMethodBuilder.define('setPublic',2);

/**
  You can enable/disable your presence using this function. Disable your presence if you don't want it to be broadcast, or its state to be set. This is similar to going "invisible".
  @function enable
  @instance
  @memberof Presence
  @param {Boolean} enable Set it to true to enable presence. Set to false for otherwise.
  @example
      var user = app.User('abc');
      user
        .getPresence()
        .then(function(presence){
          var newPresence = presence.enable(true);
        });
  @return {Presence}
*/

module.exports.enable = set('enabled');
instanceMethodBuilder.define('enable',2);

/**
  You can specify a whitelist of application users who can access your presence. By default, the presence isn't publicly visible and no one can access it.
  @function setWhiteList
  @instance
  @memberof Presence
  @param {Array} users Accepts array of user uids
  @throws new Error("Whitelist must be array");
  @example
      var user = app.User('abc');
      user
        .getPresence()
        .then(function(presence){
          var newPresence = presence.setWhiteList(['abc123','pqr123']); // abc123 and pqr123 are user uid.
        });
  @return {Presence}
*/
module.exports.setWhiteList = R.curry(function(list,presence){
  if(!utility.isArray(list))
    throw new Error("Expected users to be an array");
  return set('whitelist', R.uniq(list), presence);
});
instanceMethodBuilder.define('setWhiteList',2);

module.exports.getWhiteListUsers = function(presence){
  return presence.get('whitelist') || [];
}

module.exports.getLastSeen = function(presence){
  return presence.get('last_seen')
}

module.exports.getLastSeen = function(presence){
  return presence.get('status')
}


module.exports.addInWhiteList = R.curry(function(user, presence){
  var newWhitelist = presence.getWhiteListUsers().concat([]);
  if(utility.isObject(user) && user.get('uid')){
    newWhitelist.push(user.get('uid'))
  }else if(utility.isString(user)){
    newWhitelist.push(user)
  }else{
    throw new Error("Expected user to be a SDK object or a String");
  }
  return set('whitelist', R.uniq(newWhitelist), presence); 
})

module.exports.removeFromWhiteList = R.curry(function(user, presence){
  var newWhitelist = presence.getWhiteListUsers().concat([]);
  if(utility.isObject(user) && user.get('uid')){
    newWhitelist = utility.findAndRemove(user.get('uid'), newWhitelist)
  }else if(utility.isString(user)){
    newWhitelist = utility.findAndRemove(user, newWhitelist)
  }else{
    throw new Error("Expected 'user' to be a SDK object or a String");
  }
  return set('whitelist', R.uniq(newWhitelist), presence); 
})

/**
  Method expects a array of user's uid whose presence request is to be accepted. Internally this method removes these users from requests and adds them in whitelist.
  @function acceptRequests
  @instance
  @memberof Presence
  @param {Array} users User's uids whose request is to be accepted
  @example
      var user = app.User('abc');
      user.getPresence()
        .then(function(presence){
          var requests    = presence.getRequests(); 
          var newPresence = presence.acceptRequests(requests.slice(0,2)); //Accepts first 2 users request
          return newPresence.save();
        });
  @return {Presence}
*/
module.exports.acceptRequests = R.curry(function(list,presence){
   if(!utility.isArray(list))
    throw new Error("User's uids must be array");
  var newData          = getMixinedData(presence);
  newData['requests']  = R.difference(presence.getRequests(), list);
  newData['whitelist'] = newData['whitelist'].concat(list);
  return presenceCons(presence.app, newData);
});
instanceMethodBuilder.define('acceptRequests',2);

/**
  Saves your presence details on the server
  @function save
  @instance
  @memberof Presence
  @example
      var user = app.User('abc');
      user
        .getPresence()
        .then(function(presence) {
          presence
            .setWhiteList(['abc123', 'pqr123'])
            .setState({
              message: 'Hello'
            })
            .save()
            .then(function(presence) {
              console.log(presence.toJSON()); // updated presence details
            });
        });
  @return {Promise<Presence>}
*/
module.exports.save = function(presence){
  return socketEmit('setPresence', getData(presence), presence);
}
instanceMethodBuilder.define('save',1);

var get = module.exports.get = R.curry(function(parameter,presence){
  return R.prop(parameter,getData(presence));
});

/**
  Users can request other users to share their presence with them. You can use this method to see who all have sent requests to you.
  @function getRequests
  @instance
  @memberof Presence
  @example
      var User = app.User;
      User
        .getPresence()
        .then(function(presence){
          console.log(presence.getRequests());
        });
  @return {Array}
*/
module.exports.getRequests = get('requests');
instanceMethodBuilder.define('getRequests',1);  

/**
  Gets the current state information
  @function getStatusMessage
  @instance
  @memberof Presence
  @example
      var User = app.User;
      User
        .getPresence()
        .then(function(presence){
          console.log(presence.getStatusMessage());
        });
  @return {object}
*/
module.exports.getStatusMessage = get('state');
instanceMethodBuilder.define('getStatusMessage',1);

// For backward compatibility
module.exports.getState = get('state');
instanceMethodBuilder.define('getState',1);


/**
  Checks whether the user's presence is avaliable publicly
  @function isPublic
  @instance
  @memberof Presence
  @example
      var User = app.User;
      User
        .getPresence()
        .then(function(presence){
          console.log(presence.isPublic());
        });
  @return {Boolean}
*/
module.exports.isPublic = get('public');
instanceMethodBuilder.define('isPublic',1);

/**
  Checks whether the user's presence is enabled
  @function isEnabled
  @instance
  @memberof Presence
  @example
      var User = app.User;
      User
        .getPresence()
        .then(function(presence){
          console.log(presence.isEnabled());
        });
  @return {Boolean}
*/
module.exports.isEnabled = get('enabled');
instanceMethodBuilder.define('isEnabled',1);

/**
  Gets the application user whose presence was broadcast
  When a user logs in, his presence is broadcast to all users who have requested for his presence updates. To know the user whose presence was updated, use this method.
  @function getApplicationUser
  @instance
  @memberof Presence
  @example
      var User = app.User;
      User.on('presence',function(presence){
        console.log(presence.getApplicationUser());
      })
  @return {Boolean}
*/

module.exports.getApplicationUser = function(presence){
  return R.prop('application_user',getData(presence));
}
instanceMethodBuilder.define('getApplicationUser',1);

var socketEmit  = R.curry(function(string, payload, presence) {
  var app       = presence.app;
  var socket    = app.getSocket();
  var deferred  = when.defer();
  function emitFn(socket) {
    socket.emit(string, payload, function(err, data) {
      if (err) {
        deferred.reject(err);
      }
      if (!err && data)
        deferred.resolve(presenceCons(app, data.presence)); //server returns an object consisting a presence property
    });
  }
  if(app.isSocketConnected()){
    if (app.isSocketAuthStarted())
      app.getAdhocOperations().push(emitFn);
    else
      emitFn(app.getSocket());
  }else
    app.getAdhocOperations().push(emitFn);

  return deferred.promise;
});
